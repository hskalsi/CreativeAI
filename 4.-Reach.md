## Sections

- [Description] (#reach-description)
- [Structure] (#reach-structure)
- [Explanation of Functions Given to You] (#explanation-of-given-functions)
- [How to Make Your Final Product Unique](#how-to-make-your-final-product-unique)
- [How to Test Your Program] (#how-to-test-your-program)
- [How to Run Your Program to Generate Music] (#how-to-run-your-program-to-generate-music)
- [Turning in Your Reach](#turning-in-your-reach)

## Reach Description

For the core, you implemented a program to create a model of a music artist's lyrics. For the reach, you will do much of the same, but use pre-processed music data in text form and a cool Python program called [PySynth](./Concepts#how-pysynth-works) to create actual randomly generated music in the form of .wav files, which can be played with software like iTunes or Windows Media Player.

You are also required to include a graphical component to your reach ([see description for more details](#explanation-of-graphical-component)).

The great thing about the reach is that you get to be creative with your final output. Therefore, you only have to implement a few required functions and features, and beyond that you can add new functions to [make your final product unique](#how-to-make-your-final-product-unique).

You should be familiar with the [basics of PySynth](./Concepts#how-pysynth-works) before attempting to implement the reach.

As with the core, the _required functions_ of the reach do not require you to include any external libraries beyond what has already been included for you. Use of any other external libraries is prohibited on this part of the project. _However_, on the creative part of the reach, and on the graphical portion, you are free to use whatever tools you want.

## Reach Structure

All of the reach functions that you are required to implement are in the same files that you used for the core. You will implement [```getNextNote```](#getnextnote) in ```nGramModel.py```. In ```generate.py```, you will implement [```trainMusicModels```](#trainmusicmodels), [```generateMusicalSentence```](#generatemusicalsentence), and [```runMusicGenerator```](#runmusicgenerator). All of these functions will be similar to functions you wrote in the core.

## Explanation of Given Functions

See the [Explanation of Given Functions](./3.-Core#explanation-of-given-functions) section from the core.

## How to Make Your Final Product Unique

For the core, we had you follow a strict format for how you ultimately outputted your generated lyrics. However, for the reach, you get to be creative. Therefore, you can modify any part of the project that you want, or write new functions of your own, to achieve whatever ideas you have in mind. Here are some ideas for making your final product unique. Note that some of these alone are not enough to satisfy the creativity requirement for the reach. For this reason, we ask that you are detailed in your reach proposal so that we can notify you if it needs adjustment. Furthermore, this is not a comprehensive list of reach possibilities - feel free to think outside of the box and have fun with it! If you have any questions, please contact the project staff. 

- One thing that we recommend you do to make your music sound more cohesive is make your generated songs start with, and end with, the first note in the ```possiblePitches``` list (the key signature you randomly chose in ```runMusicGenerator```). This note in music is called the *tonic*, and starting and ending on that note makes a piece of music sound more cohesive to the listener. To do this, you can simply make a PySynth tuple with the first value being the first note in your ```possiblePitches``` list, and the second value being a random duration chosen from the ```NOTE_DURATIONS``` list (like what you did for ```getNextNote```).
- You could make songs with different sections in different key signatures.
- Try playing around with structure (think of songs you know - how are they structured? What makes them unique?)
- One thing that is missing from the music data is rests, or pauses in the music. PySynth supports rests (see the [section on PySynth](./Concepts#how-pysynth-works) for more detail), which means that after you are done generating a song, you can go back and insert rests into the song
- You could randomly generate titles for songs using the lyric data from the core.
- You could also randomly generate titles for songs using the actual titles of the songs stored in the music data folder.
- You could match your generated lyrics to your generated music, so you're creating an entire "song".
- Going back to the lyrics part of the project, you could download lyrics for multiple artists and create lyric mashups (this can be quite funny given the artists that you choose).
- PySynth provides a function called ```mix_files``` to mix two .wav files together so that you can have more than one note playing at the same time. To call ```mix_files```, you do something like this, where ```wavFile1``` and ```wavFile2``` are the files you want to combine, and ```outputWavFile``` is the file that will contain the mixed music:

```python
pysynth.mix_files(wavFile1, wavFile2, outputWavFile)
```
Basically, think about your favorite songs or pieces of music, and think about the things that make them unique lyrically or musically. Then, think about how you can represent those characteristics using the Python tools and constructs you know. 

**A few important notes**:

- For the "creative" part of the reach, you don't have to focus on making your music better if your group only wants to work with the lyrics part of the project.

- For the reach, you are allowed to change any of the functions we implemented for you: i.e. ```main```, ```getUserInput```, and so on. However, **make sure not to change the functionality of ```getNextNote```, ```trainMusicModels```, or ```generateMusicalSentence```**. This is because we plan on automatically grading these three functions, and if you change what they do then you will fail our tests. If you want to change the way your program gets a note or generates a musical sentence, just write new functions to do so.

- **IMPORTANT: you are certainly allowed to play around with your music using software like Garage Band and the likes. However, because doing so usually doesn't involve writing code or conceptual computer science, we won't award creative reach points for music improvements using such software. Feel free to use them if you want to improve your final output, but also make sure to do things that involve programming!**

## How to Test Your Program

See the section on [How to Test Your Program](./3.-Core#how-to-test-your-program) from the core.

## How to Run Your Program to Generate Music

If you are using PyCharm, open ```generate.py``` and click "Run..."  If you are working in the command line, navigate to the root Creative AI repository and run this command:

```
python generate.py
```

as you did in the core. In either case, after PySynth creates the final .wav file, you should find that file in the ```wav/``` directory, where you can open and play it.

## Turning in Your Reach

When you submit your final reach product via GitHub, please include a README.md file in the root repository. The README.md file **must** include instructions on how to run your program and any other information we would need about how it works (i.e. Windows vs Mac differences, environment variables, etc.) If we cannot run your program, grading will be much more difficult for us, and may even result in a zero for this portion of your project. See [the Grading section](./5.-Grading-Policy-and-Dates) for more info.