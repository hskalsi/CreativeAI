# Sections

- [Description] (#reach-description)
- [Structure] (#reach-structure)
- [Explanation of Functions Given to You] (#explanation-of-given-functions)
- [How to Make Your Final Product Unique](#how-to-make-your-final-product-unique)
- [How to Test Your Program] (#how-to-test-your-program)
- [How to Run Your Program to Generate Music] (#how-to-run-your-program-to-generate-music)
- [Turning in Your Reach](#turning-in-your-reach)

# Overview

Now that you've implemented the core, you can build from it to create more interesting projects. You now have a project that generates music and lyrics based on an artist's repertoire. You will build on that core to both create better models and new ways of showing your models.

The Reach, then, has two components: a Visual Component and a Data Component. **You must complete one Visual Reach and one Data Reach.** We have provided four options, but how you implement them is entirely up to your interests. There is no autograder for the Reach --  we will grade everything by hand. So feel free to explore ideas that interest you and shape your project the way you want to shape it. With that in mind, you may use any tools or external libraries you would like. Outside tools are allowed and encouraged. As long as you complete one Visual Component and one Data Component, your Reach may use any other tools you would like.

# Visual Component

You must complete one of the following Visual Components. The language models you have built are very powerful, but right now they just produce text and midi files. We want you to use one of these reaches to visualize your projects so that users can *see* the data you've produced.

## Twitterbot

For this component, you will integrate your learning model with twitter. This reach will give you experience working with twitter's API and applying your model to other kinds of data. We recommend the python library **tweepy** (though you may use others). To begin, you'll need to download the tweepy module:

```pip install tweepy```

You will also need to [register a twitter account](https://twitter.com/signup/). Feel free to customize your account however you like, but **remember to keep it eecs183-appropriate.** You will need to [generate an access token](https://themepacific.com/how-to-generate-api-key-consumer-token-access-key-for-twitter-oauth/994/) (This is what will allow your project code to be authorized to use twitter's features.) Once you've done that, you can begin working with your twitter bot. A good explanation of how to get started can be found [here](http://pythoncentral.io/introduction-to-tweepy-twitter-for-python/).

Once you get your twitter bot working, you can extend it in whatever ways interest you. You could, for instance, train your bot on a public figure's timeline and generate new tweets for that figure. You could turn your twitter bot into a public interface for your lyrics generation. Pick an option that interests you and develop it.

Note: Please keep your twitter bot eecs183-appropriate. Also note that, when we go to grade your bot, we will need need your authentication keys in order to test its capabilities. **Please include all access tokens when you submit your final project. Failure to run your code will result in its not being graded.**

## Data Visualization

For this component, you will be creating graphs and visualizations of the data you've generated with your model. This will give you experience working with plotting and graphing. We recommend the python library **matplotlib**, but you may use any equivalent libraries. To start:

```pip install matplotlib```

You will first want to familiarize yourselves with how matplotlib works. A basic tutorial can be found [here](http://matplotlib.org/users/pyplot_tutorial.html). Once you have the capability to create graphs, you will need to figure out some way of representing the data you've generated. For instance, you could use the music scraper to download different artists and then compare how different artists tend to use different words. You could graph the prevalence of different notes generated in different genres of music. You could compare the data your model generates with the corpus for a particular artist.

Pick something that sounds interesting to you and develop it.


# Data Component

You must complete one of the following Data Components. These will extend your models so that the data you produce begins to sound like real music or real song lyrics. 

## Grammatical Lyrics

This component will work on the quality of your lyric generation. What you developed in the core generates phrases, but they often don't sound like real English lyrics. We can use the python library **nltk** to provide rules to modify our language models.

To start, you will need to [download nltk](http://www.nltk.org/install.html). After downloading, you will need to [download a grammar](http://www.nltk.org/data.html) for the lyrics you want to generate. This will probably be the English grammar, though you may use other grammars if you want to extend your model to lyrics from other languages. **Please specify which grammars your program requires when you submit. If we do not know which grammars we need to download we may be unable to grade your project.**

At a simple level, nltk works by tagging words with their parts of speech. By checking the parts of speech of words as you generate them, you can construct sentences that make grammatical sense. But nltk offers many more capabilities; you will want to read some of the nltk documentation. You could, for instance, use a non-English grammar to develop your model with song lyrics from another language. You could use nltk's sentiment library to create positive or negative songs. As always, pick something that interests you and run with it.

## Musical Harmony

The last component won't involve any new libraries, but will use more of ```pysynth```'s functionalities. You will be learning about music and harmonic theories to generate songs more pleasing to the ear. While randomly-generated songs can be fun, they often don't sound anything like real music. But by mixing in other song layers, we can still use random-generation to create more complex songs that are fun to listen to.

There are a few ways to achieve this. You can start by creating a backbeat, a repetition of notes that lasts for the duration of the song. By picking a few random notes and alternating between them, you can create one layer of a more complex song.

You can also create a pentatonic progression -- a sequence of notes that moves through a chord progression in a loop throughout the rest of the song. Just by creating this layer and adding it to your songs the music you produce will be more complex.

You can also affect the quality of the random notes you generate. You can attempt to fit these into some musical pattern by not repeating the same note too many times or by producing longer patterns of notes that then get fit together in your song.

In order to do this, you will need to figure out how to merge song files together using pysynth. Do not just generate separate layers and perform them together; **if you don't create final, finished songs with your program, we will be unable to listen to and grade your project.**

# Submission

We will grade the last submission to your GitHub team repository before the project deadline. We will ***NOT*** grade earlier submissions, revert to an early commit, or make any changes to your project. We will run your project exactly as they are submitted. If you forget to push changes to your repository before the deadline we will not grade them. 

Please include a file named `README.md` root directory of your repository. The `README.md` file must include a summary of what your reach does and instructions on how to run your program. If your project uses additional external libraries you must specify them here so we know to download them. If your project only runs on Windows or Mac, please let us know so we will grade it on the proper machine. Except for external libraries, if your code does not run when we pull your repository, you will get a 0. See the Grading section for more info.

Remember, this is now your project. There is no autograder. We want you to be creative with your final project and shape your reach in a way that's interesting to *you*. You must pick one Data and one Visual option, but these options are guidelines only. 

## Reach Structure

All of the reach functions that you are required to implement are in the same files that you used for the core. You will implement [```getNextNote```](#getnextnote) in ```nGramModel.py```. In ```generate.py```, you will implement [```trainMusicModels```](#trainmusicmodels), [```generateMusicalSentence```](#generatemusicalsentence), and [```runMusicGenerator```](#runmusicgenerator). All of these functions will be similar to functions you wrote in the core.

## Explanation of Given Functions

See the [Explanation of Given Functions](./3.-Core#explanation-of-given-functions) section from the core.

## How to Make Your Final Product Unique

For the core, we had you follow a strict format for how you ultimately outputted your generated lyrics. However, for the reach, you get to be creative. Therefore, you can modify any part of the project that you want, or write new functions of your own, to achieve whatever ideas you have in mind. Here are some ideas for making your final product unique. Note that some of these alone are not enough to satisfy the creativity requirement for the reach. For this reason, we ask that you are detailed in your reach proposal so that we can notify you if it needs adjustment. Furthermore, this is not a comprehensive list of reach possibilities - feel free to think outside of the box and have fun with it! If you have any questions, please contact the project staff. 

- One thing that we recommend you do to make your music sound more cohesive is make your generated songs start with, and end with, the first note in the ```possiblePitches``` list (the key signature you randomly chose in ```runMusicGenerator```). This note in music is called the *tonic*, and starting and ending on that note makes a piece of music sound more cohesive to the listener. To do this, you can simply make a PySynth tuple with the first value being the first note in your ```possiblePitches``` list, and the second value being a random duration chosen from the ```NOTE_DURATIONS``` list (like what you did for ```getNextNote```).
- You could make songs with different sections in different key signatures.
- Try playing around with structure (think of songs you know - how are they structured? What makes them unique?)
- One thing that is missing from the music data is rests, or pauses in the music. PySynth supports rests (see the [section on PySynth](./Concepts#how-pysynth-works) for more detail), which means that after you are done generating a song, you can go back and insert rests into the song
- You could randomly generate titles for songs using the lyric data from the core.
- You could also randomly generate titles for songs using the actual titles of the songs stored in the music data folder.
- You could match your generated lyrics to your generated music, so you're creating an entire "song".
- Going back to the lyrics part of the project, you could download lyrics for multiple artists and create lyric mashups (this can be quite funny given the artists that you choose).
- PySynth provides a function called ```mix_files``` to mix two .wav files together so that you can have more than one note playing at the same time. To call ```mix_files```, you do something like this, where ```wavFile1``` and ```wavFile2``` are the files you want to combine, and ```outputWavFile``` is the file that will contain the mixed music:

```python
pysynth.mix_files(wavFile1, wavFile2, outputWavFile)
```
Basically, think about your favorite songs or pieces of music, and think about the things that make them unique lyrically or musically. Then, think about how you can represent those characteristics using the Python tools and constructs you know. 

**A few important notes**:

- For the "creative" part of the reach, you don't have to focus on making your music better if your group only wants to work with the lyrics part of the project.

- For the reach, you are allowed to change any of the functions we implemented for you: i.e. ```main```, ```getUserInput```, and so on. However, **make sure not to change the functionality of ```getNextNote```, ```trainMusicModels```, or ```generateMusicalSentence```**. This is because we plan on automatically grading these three functions, and if you change what they do then you will fail our tests. If you want to change the way your program gets a note or generates a musical sentence, just write new functions to do so.

- **IMPORTANT: you are certainly allowed to play around with your music using software like Garage Band and the likes. However, because doing so usually doesn't involve writing code or conceptual computer science, we won't award creative reach points for music improvements using such software. Feel free to use them if you want to improve your final output, but also make sure to do things that involve programming!**

## How to Test Your Program

See the section on [How to Test Your Program](./3.-Core#how-to-test-your-program) from the core.

## How to Run Your Program to Generate Music

If you are using PyCharm, open ```generate.py``` and click "Run..."  If you are working in the command line, navigate to the root Creative AI repository and run this command:

```
python generate.py
```

as you did in the core. In either case, after PySynth creates the final .wav file, you should find that file in the ```wav/``` directory, where you can open and play it.

## Turning in Your Reach

When you submit your final reach product via GitHub, please include a README.md file in the root repository. The README.md file **must** include instructions on how to run your program and any other information we would need about how it works (i.e. Windows vs Mac differences, environment variables, etc.) If we cannot run your program, grading will be much more difficult for us, and may even result in a zero for this portion of your project. See [the Grading section](./5.-Grading-Policy-and-Dates) for more info.